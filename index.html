<script>
  // white at top, black at bottom
  const initialBoard = [
    ['R', 'H', 'B', 'K', 'Q', 'B', 'H', 'R'],
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
    ['.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.'],
    ['.', '.', '.', '.', '.', '.', '.', '.'],
    ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
    ['r', 'h', 'b', 'k', 'q', 'b', 'h', 'r'],
  ];

  const getRank = (pos) => pos[0];
  const getFile = (pos) => pos[1];
  const isEmpty = (square) => square === '.';
  const isWhitePiece = (square) =>
    !isEmpty(square) && square.toUpperCase() === square;
  const isBlackPiece = (square) =>
    !isEmpty(square) && square.toLowerCase() === square;
  const isWithinBoard = (pos) =>
    getRank(pos) >= 0 &&
    getRank(pos) <= 7 &&
    getFile(pos) >= 0 &&
    getFile(pos) <= 7;
  const getSquaresBetween = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const minRank = Math.min(startRank, endRank);
    const minFile = Math.min(startFile, endFile);
    const maxFile = Math.max(startFile, endFile);

    if (numRanksMoved === 0) {
      return board[startRank].slice(minFile + 1, numFilesMoved);
    }

    if (numFilesMoved === 0) {
      return board
        .slice(minRank + 1, minRank + numRanksMoved)
        .map((arr) => arr[startFile]);
    }

    if (numRanksMoved === numFilesMoved) {
      return board
        .slice(minRank + 1, minRank + numRanksMoved)
        .map(
          (arr, i) =>
            arr[
              startFile - endFile === startRank - endRank
                ? minFile + i + 1
                : maxFile - i - 1
            ]
        );
    }

    return [];
  };
  // @todo handle en passant
  const isValidPawnMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const startSquare = board[startRank][startFile];
    const endSquare = board[endRank][endFile];
    const isWhite = isWhitePiece(startSquare);
    const isBlack = isBlackPiece(startSquare);
    const isInitialRank = isWhite ? startRank === 1 : startRank === 6;
    const isDiagonal = numRanksMoved !== 0 && numFilesMoved !== 0;
    const isCapture = !isEmpty(endSquare);

    if (!isInitialRank && numRanksMoved !== 1) {
      throw new Error('moved too far');
    }

    if (isInitialRank && !(numRanksMoved === 1 || numRanksMoved === 2)) {
      throw new Error('moved too far');
    }

    if (
      (isWhite && startRank - endRank > 0) ||
      (isBlack && startRank - endRank < 0)
    ) {
      throw new Error('moved in wrong direction');
    }

    if (isDiagonal && !(numRanksMoved === 1 && numFilesMoved === 1)) {
      throw new Error('moved too far diagonally');
    }

    if (isDiagonal && !isCapture) {
      throw new Error('moved diagonally without capturing');
    }

    if (!isDiagonal && isCapture) {
      throw new Error('can only capture diagonally');
    }

    if (numFilesMoved > 1) {
      throw new Error('moved too many files');
    }

    if (
      numRanksMoved === 2 &&
      !isEmpty(board[(startRank + endRank) / 2][startFile])
    ) {
      throw new Error('jumped another piece');
    }
  };
  const isValidRookMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const isVertical = numRanksMoved !== 0;
    const isUp = isVertical && startRank > endRank;
    const isDown = isVertical && startRank < endRank;
    const isHorizontal = numFilesMoved !== 0;
    const isLeft = isHorizontal && startFile > endFile;
    const isRight = isHorizontal && startFile < endFile;
    const isDiagonal = isVertical && isHorizontal;
    const squaresBetween = getSquaresBetween(board, start, end);

    if (isDiagonal) {
      throw new Error('cannot move diagonally');
    }

    if (!squaresBetween.every(isEmpty)) {
      throw new Error('jumped another piece');
    }
  };
  const isValidKnightMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);

    if (
      !(
        numRanksMoved < 3 &&
        numFilesMoved < 3 &&
        numRanksMoved + numFilesMoved === 3
      )
    ) {
      throw new Error('invalid move');
    }
  };
  const isValidBishopMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const isDiagonal = numRanksMoved === numFilesMoved;
    const squaresBetween = getSquaresBetween(board, start, end);

    if (!isDiagonal) {
      throw new Error('must move diagonally');
    }

    if (!squaresBetween.every(isEmpty)) {
      throw new Error('jumped another piece');
    }
  };
  const isValidQueenMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const isVertical = numRanksMoved !== 0;
    const isHorizontal = numFilesMoved !== 0;
    const isDiagonal = isVertical && isHorizontal;
    const squaresBetween = getSquaresBetween(board, start, end);

    if (!(isVertical || isHorizontal || isDiagonal)) {
      throw new Error('can only move vertically, horizontally, or diagonally');
    }

    if (!squaresBetween.every(isEmpty)) {
      throw new Error('jumped another piece');
    }
  };
  // @todo not moving into (or through) check
  // @todo handle castling
  const isValidKingMove = (board, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const numRanksMoved = Math.abs(startRank - endRank);
    const numFilesMoved = Math.abs(startFile - endFile);
    const isVertical = numRanksMoved !== 0;
    const isHorizontal = numFilesMoved !== 0;
    const isDiagonal = isVertical && isHorizontal;

    if (!(isVertical || isHorizontal || isDiagonal)) {
      throw new Error('can only move vertically, horizontally, or diagonally');
    }

    if (numRanksMoved > 1 || numFilesMoved > 1) {
      throw new Error('cannot move more than one square at a time');
    }
  };
  // @todo validate board?

  const isValidMove = (board = initialBoard, start, end) => {
    const startRank = getRank(start);
    const endRank = getRank(end);
    const startFile = getFile(start);
    const endFile = getFile(end);
    const startSquare = board[startRank][startFile];
    const endSquare = board[endRank][endFile];

    try {
      if (!isWithinBoard(start) || !isWithinBoard(end)) {
        throw new Error('invalid square');
      }

      if (isEmpty(startSquare)) {
        throw new Error('no piece on start square to move');
      }

      if (startRank === endRank && startFile === endFile) {
        throw new Error('did not move to another square');
      }

      if (
        (isWhitePiece(startSquare) && isWhitePiece(endSquare)) ||
        (isBlackPiece(startSquare) && isBlackPiece(endSquare))
      ) {
        throw new Error('end square already occupied');
      }

      switch (startSquare.toLowerCase()) {
        case 'p':
          isValidPawnMove(board, start, end);
          break;

        case 'r':
          isValidRookMove(board, start, end);
          break;

        case 'h':
          isValidKnightMove(board, start, end);
          break;

        case 'b':
          isValidBishopMove(board, start, end);
          break;

        case 'q':
          isValidQueenMove(board, start, end);
          break;

        case 'k':
          isValidKingMove(board, start, end);
          break;
      }

      return true;
    } catch (err) {
      console.error(err);

      return false;
    }
  };
</script>
